import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.animation import FuncAnimation
from scipy.integrate import dblquad

# Definir constantes
a = float(input('Ingrese la longitud en x de la placa (en m): '))
b = float(input('Ingrese la longitud en y de la placa (en m): '))
alpha = float(input('Ingrese la constante de difusión térmica α (en m^2 / s)'))
f_opt = input('Ingrese alguna de las siguientes opciones para la distribución inicial del calor f(x,y):\n1. Distribución Gaussiana\n2. Seno\n3.Personalizada')

while(True):
    if f_opt == '1':
        break
    elif f_opt == '2':
        break
    elif f_opt == '3':
        f_str = input('Ingrese la función f(x,y) = ')
        break
    else:
        f_opt = input('Ingresa alguna de las 3 opciones: ')



def f(x, y):
    x_center = a / 2
    y_center = b / 2

    amplitude = 15
    sigma_x = a / 4  # Controla la dispersión en dirección x
    sigma_y = b / 4  # Controla la dispersión en dirección y

    gaussian = amplitude * np.exp(-((x - x_center)**2 / (2 * sigma_x**2) + (y - y_center)**2 / (2 * sigma_y**2)))
    return gaussian


def f_sin(x, y):
    return 10 * np.sin(9*x)**2 + 3**y


# Calcular los coeficientes Cnm4
def Cnm(n, m):
    integrand = lambda x, y: f_sin(x, y) * np.sin(n * np.pi * x / a) * np.sin(m * np.pi * y / b)
    integral, _ = dblquad(integrand, 0, b, lambda y: 0, lambda y: a)
    return (4 / (a * b)) * integral

# Calcular la temperatura en un punto (x, y, t) según la ecuación dada
def temperature(x, y, t, n_max=5, m_max=5):
    result = 0
    for n in range(1, n_max + 1):
        for m in range(1, m_max + 1):
            lambda_nm = (n * np.pi / a)**2 + (m * np.pi / b)**2
            result += Cnm(n, m) * np.sin(n * np.pi * x / a) * np.sin(m * np.pi * y / b) * np.exp(-alpha * lambda_nm * t)
    return result

# Crear la malla de puntos en la placa
x = np.linspace(0, a, 100)
y = np.linspace(0, b, 100)
X, Y = np.meshgrid(x, y)

# Crear la figura y el subplot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Función para generar los datos de temperatura en cada instante de tiempo
def generate_data(frame):
    Z = temperature(X, Y, frame)
    return Z

initial_temperature = generate_data(0)
surf = [ax.plot_surface(X, Y, initial_temperature, cmap='hot')]

# Get the maximum temperature value to set the colorbar range
max_temperature = initial_temperature.max()

# Modify the update function to update the colorbar range and colormap
def update(frame, surf, ax):
    ax.clear()
    ax.set_zlim(0, max_temperature)
    ax.set_title('Frame {}'.format(frame))
    new_data = generate_data(frame)
    surf[0] = ax.plot_surface(X, Y, new_data, cmap='hot', vmin=0, vmax=max_temperature)
    return surf

# Crear la animación
ani = FuncAnimation(fig, update, frames=np.linspace(0, 100, 1000), fargs=(surf, ax), interval=50)

# Mostrar la animación
plt.show()